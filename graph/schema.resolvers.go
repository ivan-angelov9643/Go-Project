package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"awesomeProject/graph/model"
	"awesomeProject/library-app/managers"
	"awesomeProject/library-app/models"
	"context"
	"fmt"
	"github.com/google/uuid"
)

func (r *mutationResolver) CreateBook(ctx context.Context, title string, year int32, authorID string, categoryID string, totalCopies int32, language string) (*model.Book, error) {
	book, err := GORMBookModel(title, year, authorID, categoryID, totalCopies, language)
	if err != nil {
		return nil, err
	}

	newBook, err := r.BookResolver.BookManager.Create(*book)
	if err != nil {
		return nil, err
	}

	graphQLBook := ToGraphQLBookModel(newBook)
	return &graphQLBook, nil
}

func (r *mutationResolver) UpdateBook(ctx context.Context, id string, title *string, year *int32, totalCopies *int32, language *string) (*model.Book, error) {
	bookID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid book ID: %w", err)
	}

	updatedBook := models.Book{
		BaseModel:   models.BaseModel{ID: bookID},
		Title:       derefString(title),
		Year:        derefInt(year),
		TotalCopies: derefInt(totalCopies),
		Language:    derefString(language),
	}

	book, err := r.BookResolver.BookManager.Update(updatedBook)
	if err != nil {
		return nil, err
	}

	graphQLBook := ToGraphQLBookModel(book)
	return &graphQLBook, nil
}

func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	bookID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid book ID: %w", err)
	}

	_, err = r.BookResolver.BookManager.Delete(bookID)
	return err == nil, err
}

func (r *mutationResolver) CreateCategory(ctx context.Context, name string, description *string) (*model.Category, error) {
	category := GORMCategoryModel(name, description)

	newCategory, err := r.BookResolver.CategoryManager.Create(*category)
	if err != nil {
		return nil, err
	}

	graphQLCategory := ToGraphQLCategoryModel(newCategory)
	return &graphQLCategory, nil
}

func (r *mutationResolver) UpdateCategory(ctx context.Context, id string, name *string, description *string) (*model.Category, error) {
	categoryID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid category ID: %w", err)
	}

	updatedCategory := models.Category{
		BaseModel:   models.BaseModel{ID: categoryID},
		Name:        derefString(name),
		Description: description,
	}

	category, err := r.BookResolver.CategoryManager.Update(updatedCategory)
	if err != nil {
		return nil, err
	}

	graphQLCategory := ToGraphQLCategoryModel(category)
	return &graphQLCategory, nil
}

func (r *mutationResolver) DeleteCategory(ctx context.Context, id string) (bool, error) {
	categoryID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid category ID: %w", err)
	}

	_, err = r.BookResolver.CategoryManager.Delete(categoryID)
	return err == nil, err
}

func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) {
	books, err := r.Resolver.BookResolver.BookManager.GetAll()
	if err != nil {
		return nil, err
	}

	var graphQLBooks []*model.Book
	for _, book := range books {
		b := ToGraphQLBookModel(book)
		graphQLBooks = append(graphQLBooks, &b)
	}

	return graphQLBooks, nil
}

func (r *queryResolver) Book(ctx context.Context, id string) (*model.Book, error) {
	bookID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid book ID: %w", err)
	}

	book, err := r.Resolver.BookResolver.BookManager.Get(bookID)
	if err != nil {
		return nil, err
	}

	graphQLBook := ToGraphQLBookModel(book)
	return &graphQLBook, nil
}

func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	categories, err := r.BookResolver.CategoryManager.GetAll()
	if err != nil {
		return nil, err
	}

	var graphQLCategories []*model.Category
	for _, category := range categories {
		c := ToGraphQLCategoryModel(category)
		graphQLCategories = append(graphQLCategories, &c)
	}

	return graphQLCategories, nil
}

func (r *queryResolver) Category(ctx context.Context, id string) (*model.Category, error) {
	categoryID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid category ID: %w", err)
	}

	category, err := r.BookResolver.CategoryManager.Get(categoryID)
	if err != nil {
		return nil, err
	}

	graphQLCategory := ToGraphQLCategoryModel(category)
	return &graphQLCategory, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

type BookResolver struct {
	CategoryManager managers.CategoryManagerInterface
	BookManager     managers.BookManagerInterface
}

func (r *BookResolver) Category(ctx context.Context, obj *model.Book) (*model.Category, error) {
	categoryID, err := uuid.Parse(obj.Category.ID)
	if err != nil {
		return nil, err
	}

	category, err := r.CategoryManager.Get(categoryID)
	if err != nil {
		return nil, err
	}

	graphQLCategory := ToGraphQLCategoryModel(category)
	return &graphQLCategory, nil
}

func (r *Resolver) Book() *BookResolver {
	return &BookResolver{r.CategoryManager}
}
